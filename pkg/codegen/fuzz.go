package codegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/135yshr/meow/pkg/ast"
)

// GenerateFuzz produces Go fuzz test source from a Program AST.
// It converts fuzz_ prefixed functions into Go FuzzXxx functions.
// Returns two strings: helper code (main.go) and fuzz test code (main_test.go).
func (g *Generator) GenerateFuzz(prog *ast.Program) (helpers string, fuzzTests string, err error) {
	type fuzzFunc struct {
		name   string
		fn     *ast.FuncStmt
		seeds  [][]ast.Expr
		params []string
	}

	var funcs []fuzzFunc
	var helperFuncs []string

	for _, stmt := range prog.Stmts {
		fn, ok := stmt.(*ast.FuncStmt)
		if !ok {
			code, err := g.genStmtOrError(stmt)
			if err != nil {
				return "", "", err
			}
			if code != "" {
				g.topLevel = append(g.topLevel, code)
			}
			continue
		}
		if strings.HasPrefix(fn.Name, "fuzz_") {
			seeds := extractSeeds(fn)
			funcs = append(funcs, fuzzFunc{
				name:   fn.Name,
				fn:     fn,
				seeds:  seeds,
				params: fn.Params,
			})
		} else {
			helperFuncs = append(helperFuncs, g.genFuncDecl(fn))
		}
	}

	// Ensure testing import is registered before capturing import names
	g.ensureImport("testing")

	// Generate helpers (main.go)
	var hb strings.Builder
	hb.WriteString("// Code generated by meow compiler. DO NOT EDIT.\n")
	hb.WriteString("package main\n\n")
	hb.WriteString("import meow \"github.com/135yshr/meow/runtime/meowrt\"\n")
	names := make([]string, 0, len(g.imports))
	for name := range g.imports {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		fmt.Fprintf(&hb, "import meow_%s \"%s\"\n", name, g.imports[name])
	}
	hb.WriteString("\n")
	for _, fn := range helperFuncs {
		hb.WriteString(fn)
		hb.WriteString("\n\n")
	}
	// suppress unused import
	hb.WriteString("var _ = meow.NewNil\n")

	// Generate fuzz tests (main_test.go)
	var fb strings.Builder
	fb.WriteString("// Code generated by meow compiler. DO NOT EDIT.\n")
	fb.WriteString("package main\n\n")
	fb.WriteString("import (\n")
	fb.WriteString("\t\"testing\"\n\n")
	fb.WriteString("\tmeow \"github.com/135yshr/meow/runtime/meowrt\"\n")
	for _, name := range names {
		fmt.Fprintf(&fb, "\tmeow_%s \"%s\"\n", name, g.imports[name])
	}
	fb.WriteString(")\n\n")
	// suppress unused imports
	fb.WriteString("var _ = meow.NewNil\n")
	fb.WriteString("var _ = meow_testing.Judge\n\n")

	for _, ff := range funcs {
		goName := "Fuzz" + capitalizeFirst(strings.TrimPrefix(ff.name, "fuzz_"))

		fmt.Fprintf(&fb, "func %s(f *testing.F) {\n", goName)

		// Add seeds
		for _, seed := range ff.seeds {
			seedArgs := make([]string, len(seed))
			for i, s := range seed {
				seedArgs[i] = g.fuzzSeedLiteral(s)
			}
			fmt.Fprintf(&fb, "\tf.Add(%s)\n", strings.Join(seedArgs, ", "))
		}

		// Generate Fuzz function
		fuzzParams := make([]string, len(ff.params))
		fuzzParamTypes := make([]string, len(ff.params))
		for i, p := range ff.params {
			typ := g.inferFuzzType(ff.seeds, i)
			fuzzParams[i] = fmt.Sprintf("%s_raw %s", p, typ)
			fuzzParamTypes[i] = typ
		}

		fmt.Fprintf(&fb, "\tf.Fuzz(func(t *testing.T, %s) {\n", strings.Join(fuzzParams, ", "))

		// Convert raw params to meow values
		for i, p := range ff.params {
			converter := g.fuzzConverter(fuzzParamTypes[i], p+"_raw")
			fmt.Fprintf(&fb, "\t\t%s := %s\n", p, converter)
		}

		// Generate body (excluding seed calls)
		for _, stmt := range ff.fn.Body {
			if isSeedCall(stmt) {
				continue
			}
			fmt.Fprintf(&fb, "\t\t%s\n", g.genStmt(stmt))
		}

		fb.WriteString("\t})\n")
		fb.WriteString("}\n\n")
	}

	return hb.String(), fb.String(), nil
}

func extractSeeds(fn *ast.FuncStmt) [][]ast.Expr {
	var seeds [][]ast.Expr
	for _, stmt := range fn.Body {
		if es, ok := stmt.(*ast.ExprStmt); ok {
			if call, ok := es.Expr.(*ast.CallExpr); ok {
				if ident, ok := call.Fn.(*ast.Ident); ok && ident.Name == "seed" {
					seeds = append(seeds, call.Args)
				}
			}
		}
	}
	return seeds
}

func isSeedCall(stmt ast.Stmt) bool {
	es, ok := stmt.(*ast.ExprStmt)
	if !ok {
		return false
	}
	call, ok := es.Expr.(*ast.CallExpr)
	if !ok {
		return false
	}
	ident, ok := call.Fn.(*ast.Ident)
	return ok && ident.Name == "seed"
}

func (g *Generator) fuzzSeedLiteral(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.IntLit:
		return fmt.Sprintf("int64(%d)", e.Value)
	case *ast.FloatLit:
		return fmt.Sprintf("float64(%g)", e.Value)
	case *ast.StringLit:
		return fmt.Sprintf("%q", e.Value)
	case *ast.BoolLit:
		return fmt.Sprintf("%t", e.Value)
	default:
		return "int64(0)"
	}
}

func (g *Generator) inferFuzzType(seeds [][]ast.Expr, paramIndex int) string {
	for _, seed := range seeds {
		if paramIndex < len(seed) {
			switch seed[paramIndex].(type) {
			case *ast.IntLit:
				return "int64"
			case *ast.FloatLit:
				return "float64"
			case *ast.StringLit:
				return "string"
			case *ast.BoolLit:
				return "bool"
			}
		}
	}
	return "int64"
}

func (g *Generator) fuzzConverter(typ, rawVar string) string {
	switch typ {
	case "int64":
		return fmt.Sprintf("meow.NewInt(%s)", rawVar)
	case "float64":
		return fmt.Sprintf("meow.NewFloat(%s)", rawVar)
	case "string":
		return fmt.Sprintf("meow.NewString(%s)", rawVar)
	case "bool":
		return fmt.Sprintf("meow.NewBool(%s)", rawVar)
	default:
		return fmt.Sprintf("meow.NewInt(%s)", rawVar)
	}
}
