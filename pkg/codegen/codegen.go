package codegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/135yshr/meow/pkg/ast"
	"github.com/135yshr/meow/pkg/mutation"
	"github.com/135yshr/meow/pkg/token"
)

// Generator produces Go source code from a Meow AST.
type Generator struct {
	funcs     []string
	topLevel  []string
	indent    int
	imports   map[string]string // meow pkg name â†’ Go import path
	testMode  bool
	testFuncs []string // names of test_ prefixed functions
	mutations map[ast.Expr][]mutation.MutationEntry
}

var stdPackages = map[string]string{
	"file":    "github.com/135yshr/meow/runtime/file",
	"http":    "github.com/135yshr/meow/runtime/http",
	"testing": "github.com/135yshr/meow/runtime/testing",
}

// capitalizeFirst returns s with its first byte uppercased.
// Returns s unchanged if s is empty.
func capitalizeFirst(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// New creates a new code generator.
func New() *Generator {
	return &Generator{}
}

// NewTest creates a code generator in test mode.
func NewTest() *Generator {
	return &Generator{testMode: true}
}

// SetMutations sets the mutation schema for schemata-based mutation testing.
func (g *Generator) SetMutations(m map[ast.Expr][]mutation.MutationEntry) {
	g.mutations = m
}

// Generate produces Go source code from a Program AST.
func (g *Generator) Generate(prog *ast.Program) (string, error) {
	for _, stmt := range prog.Stmts {
		if fn, ok := stmt.(*ast.FuncStmt); ok {
			g.funcs = append(g.funcs, g.genFuncDecl(fn))
		} else {
			code, err := g.genStmtOrError(stmt)
			if err != nil {
				return "", err
			}
			if code != "" {
				g.topLevel = append(g.topLevel, code)
			}
		}
	}
	return g.emit(), nil
}

// GenerateTest produces Go source code from a Program AST in test mode.
// It auto-imports the testing package and wraps test_ functions with Run/Report.
func (g *Generator) GenerateTest(prog *ast.Program) (string, error) {
	for _, stmt := range prog.Stmts {
		if fn, ok := stmt.(*ast.FuncStmt); ok {
			g.funcs = append(g.funcs, g.genFuncDecl(fn))
			if strings.HasPrefix(fn.Name, "test_") {
				if len(fn.Params) != 0 {
					return "", fmt.Errorf("test function %s must not take parameters", fn.Name)
				}
				g.testFuncs = append(g.testFuncs, fn.Name)
			}
		} else {
			code, err := g.genStmtOrError(stmt)
			if err != nil {
				return "", err
			}
			if code != "" {
				g.topLevel = append(g.topLevel, code)
			}
		}
	}
	g.ensureImport("testing")
	return g.emitTest(), nil
}

func (g *Generator) emitTest() string {
	var b strings.Builder
	b.WriteString("// Code generated by meow compiler. DO NOT EDIT.\n")
	b.WriteString("package main\n\n")
	b.WriteString("import meow \"github.com/135yshr/meow/runtime/meowrt\"\n")
	if len(g.mutations) > 0 {
		b.WriteString("import \"os\"\n")
		b.WriteString("import \"strconv\"\n")
	}
	names := make([]string, 0, len(g.imports))
	for name := range g.imports {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		fmt.Fprintf(&b, "import meow_%s \"%s\"\n", name, g.imports[name])
	}
	b.WriteString("\n")

	if len(g.mutations) > 0 {
		b.WriteString("var __mutant int = -1\n\n")
		b.WriteString("func init() {\n")
		b.WriteString("\tif s := os.Getenv(\"MEOW_MUTANT\"); s != \"\" {\n")
		b.WriteString("\t\tif v, err := strconv.Atoi(s); err == nil {\n")
		b.WriteString("\t\t\t__mutant = v\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
		b.WriteString("}\n\n")
	}

	for _, fn := range g.funcs {
		b.WriteString(fn)
		b.WriteString("\n\n")
	}

	b.WriteString("func main() {\n")
	for _, line := range g.topLevel {
		b.WriteString("\t")
		b.WriteString(line)
		b.WriteString("\n")
	}
	for _, name := range g.testFuncs {
		fmt.Fprintf(&b, "\tmeow_testing.Run(meow.NewString(%q), meow.NewFunc(%q, func(args ...meow.Value) meow.Value {\n", name, name)
		fmt.Fprintf(&b, "\t\treturn %s()\n", name)
		fmt.Fprintf(&b, "\t}))\n")
	}
	b.WriteString("\tmeow_testing.Report()\n")
	b.WriteString("}\n")
	return b.String()
}

func (g *Generator) ensureImport(name string) {
	if g.imports == nil {
		g.imports = make(map[string]string)
	}
	if _, ok := g.imports[name]; !ok {
		if path, ok := stdPackages[name]; ok {
			g.imports[name] = path
		}
	}
}

func (g *Generator) emit() string {
	var b strings.Builder
	b.WriteString("// Code generated by meow compiler. DO NOT EDIT.\n")
	b.WriteString("package main\n\n")
	b.WriteString("import meow \"github.com/135yshr/meow/runtime/meowrt\"\n")
	if len(g.mutations) > 0 {
		b.WriteString("import \"os\"\n")
		b.WriteString("import \"strconv\"\n")
	}
	names := make([]string, 0, len(g.imports))
	for name := range g.imports {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		fmt.Fprintf(&b, "import meow_%s \"%s\"\n", name, g.imports[name])
	}
	b.WriteString("\n")

	if len(g.mutations) > 0 {
		b.WriteString("var __mutant int = -1\n\n")
		b.WriteString("func init() {\n")
		b.WriteString("\tif s := os.Getenv(\"MEOW_MUTANT\"); s != \"\" {\n")
		b.WriteString("\t\tif v, err := strconv.Atoi(s); err == nil {\n")
		b.WriteString("\t\t\t__mutant = v\n")
		b.WriteString("\t\t}\n")
		b.WriteString("\t}\n")
		b.WriteString("}\n\n")
	}

	for _, fn := range g.funcs {
		b.WriteString(fn)
		b.WriteString("\n\n")
	}

	b.WriteString("func main() {\n")
	for _, line := range g.topLevel {
		b.WriteString("\t")
		b.WriteString(line)
		b.WriteString("\n")
	}
	b.WriteString("}\n")
	return b.String()
}

func (g *Generator) genFuncDecl(fn *ast.FuncStmt) string {
	var b strings.Builder
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = p + " meow.Value"
	}
	fmt.Fprintf(&b, "func %s(%s) meow.Value {\n", fn.Name, strings.Join(params, ", "))
	for _, stmt := range fn.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	if !g.blockAlwaysReturns(fn.Body) {
		b.WriteString("\treturn meow.NewNil()\n")
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) blockAlwaysReturns(stmts []ast.Stmt) bool {
	if len(stmts) == 0 {
		return false
	}
	switch s := stmts[len(stmts)-1].(type) {
	case *ast.ReturnStmt:
		return true
	case *ast.IfStmt:
		return g.blockAlwaysReturns(s.Body) && g.blockAlwaysReturns(s.ElseBody)
	default:
		return false
	}
}

func (g *Generator) genStmt(stmt ast.Stmt) string {
	switch s := stmt.(type) {
	case *ast.VarStmt:
		return fmt.Sprintf("var %s meow.Value = %s", s.Name, g.genExpr(s.Value))
	case *ast.AssignStmt:
		return fmt.Sprintf("%s = %s", s.Name, g.genExpr(s.Value))
	case *ast.ReturnStmt:
		if s.Value != nil {
			return fmt.Sprintf("return %s", g.genExpr(s.Value))
		}
		return "return meow.NewNil()"
	case *ast.ExprStmt:
		return g.genExpr(s.Expr)
	case *ast.IfStmt:
		return g.genIf(s)
	case *ast.WhileStmt:
		return g.genWhile(s)
	default:
		return fmt.Sprintf("/* unsupported stmt: %T */", stmt)
	}
}

func (g *Generator) genStmtOrError(stmt ast.Stmt) (string, error) {
	if s, ok := stmt.(*ast.FetchStmt); ok {
		path, ok := stdPackages[s.Path]
		if !ok {
			return "", fmt.Errorf("unknown package: %s", s.Path)
		}
		if g.imports == nil {
			g.imports = make(map[string]string)
		}
		g.imports[s.Path] = path
		return "", nil
	}
	return g.genStmt(stmt), nil
}

func (g *Generator) genIf(s *ast.IfStmt) string {
	var b strings.Builder
	fmt.Fprintf(&b, "if (%s).IsTruthy() {\n", g.genExpr(s.Condition))
	for _, stmt := range s.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	if len(s.ElseBody) > 0 {
		b.WriteString("} else {\n")
		for _, stmt := range s.ElseBody {
			b.WriteString("\t")
			b.WriteString(g.genStmt(stmt))
			b.WriteString("\n")
		}
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) genWhile(s *ast.WhileStmt) string {
	var b strings.Builder
	fmt.Fprintf(&b, "for (%s).IsTruthy() {\n", g.genExpr(s.Condition))
	for _, stmt := range s.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) genExpr(expr ast.Expr) string {
	if entries, ok := g.mutations[expr]; ok && len(entries) > 0 {
		return g.genMutatedExpr(expr, entries)
	}
	switch e := expr.(type) {
	case *ast.IntLit:
		return fmt.Sprintf("meow.NewInt(%d)", e.Value)
	case *ast.FloatLit:
		return fmt.Sprintf("meow.NewFloat(%g)", e.Value)
	case *ast.StringLit:
		return fmt.Sprintf("meow.NewString(%q)", e.Value)
	case *ast.BoolLit:
		if e.Value {
			return "meow.NewBool(true)"
		}
		return "meow.NewBool(false)"
	case *ast.NilLit:
		return "meow.NewNil()"
	case *ast.Ident:
		return g.genIdent(e)
	case *ast.UnaryExpr:
		return g.genUnary(e)
	case *ast.BinaryExpr:
		return g.genBinary(e)
	case *ast.CallExpr:
		return g.genCall(e)
	case *ast.LambdaExpr:
		return g.genLambda(e)
	case *ast.ListLit:
		return g.genList(e)
	case *ast.IndexExpr:
		return g.genIndex(e)
	case *ast.PipeExpr:
		return g.genPipe(e)
	case *ast.CatchExpr:
		return g.genCatch(e)
	case *ast.MapLit:
		return g.genMap(e)
	case *ast.MatchExpr:
		return g.genMatch(e)
	case *ast.MemberExpr:
		obj, ok := e.Object.(*ast.Ident)
		if ok {
			return fmt.Sprintf("meow_%s.%s", obj.Name, capitalizeFirst(e.Member))
		}
		return "/* unsupported member access */"
	default:
		return fmt.Sprintf("/* unsupported expr: %T */", expr)
	}
}

func (g *Generator) genIdent(e *ast.Ident) string {
	return e.Name
}

func (g *Generator) genUnary(e *ast.UnaryExpr) string {
	switch e.Op {
	case token.MINUS:
		return fmt.Sprintf("meow.Negate(%s)", g.genExpr(e.Right))
	case token.NOT:
		return fmt.Sprintf("meow.Not(%s)", g.genExpr(e.Right))
	default:
		return fmt.Sprintf("/* unsupported unary: %v */", e.Op)
	}
}

func (g *Generator) genBinary(e *ast.BinaryExpr) string {
	l := g.genExpr(e.Left)
	r := g.genExpr(e.Right)
	switch e.Op {
	case token.PLUS:
		return fmt.Sprintf("meow.Add(%s, %s)", l, r)
	case token.MINUS:
		return fmt.Sprintf("meow.Sub(%s, %s)", l, r)
	case token.STAR:
		return fmt.Sprintf("meow.Mul(%s, %s)", l, r)
	case token.SLASH:
		return fmt.Sprintf("meow.Div(%s, %s)", l, r)
	case token.PERCENT:
		return fmt.Sprintf("meow.Mod(%s, %s)", l, r)
	case token.EQ:
		return fmt.Sprintf("meow.Equal(%s, %s)", l, r)
	case token.NEQ:
		return fmt.Sprintf("meow.NotEqual(%s, %s)", l, r)
	case token.LT:
		return fmt.Sprintf("meow.LessThan(%s, %s)", l, r)
	case token.GT:
		return fmt.Sprintf("meow.GreaterThan(%s, %s)", l, r)
	case token.LTE:
		return fmt.Sprintf("meow.LessEqual(%s, %s)", l, r)
	case token.GTE:
		return fmt.Sprintf("meow.GreaterEqual(%s, %s)", l, r)
	case token.AND:
		return fmt.Sprintf("meow.And(%s, %s)", l, r)
	case token.OR:
		return fmt.Sprintf("meow.Or(%s, %s)", l, r)
	default:
		return fmt.Sprintf("/* unsupported op: %v */", e.Op)
	}
}

func (g *Generator) genCall(e *ast.CallExpr) string {
	if member, ok := e.Fn.(*ast.MemberExpr); ok {
		return g.genMemberCall(member, e.Args)
	}
	ident, isIdent := e.Fn.(*ast.Ident)
	args := make([]string, len(e.Args))
	for i, a := range e.Args {
		args[i] = g.genExpr(a)
	}
	argStr := strings.Join(args, ", ")

	if isIdent {
		switch ident.Name {
		case "nya":
			return fmt.Sprintf("meow.Nya(%s)", argStr)
		case "hiss":
			return fmt.Sprintf("meow.Hiss(%s)", argStr)
		case "lick":
			return fmt.Sprintf("meow.Lick(%s)", argStr)
		case "picky":
			return fmt.Sprintf("meow.Picky(%s)", argStr)
		case "curl":
			return fmt.Sprintf("meow.Curl(%s)", argStr)
		case "len":
			return fmt.Sprintf("meow.Len(%s)", argStr)
		case "head":
			return fmt.Sprintf("meow.Head(%s)", argStr)
		case "tail":
			return fmt.Sprintf("meow.Tail(%s)", argStr)
		case "append":
			return fmt.Sprintf("meow.Append(%s)", argStr)
		case "toInt":
			return fmt.Sprintf("meow.ToInt(%s)", argStr)
		case "toFloat":
			return fmt.Sprintf("meow.ToFloat(%s)", argStr)
		case "toString":
			return fmt.Sprintf("meow.ToString(%s)", argStr)
		case "gag":
			return fmt.Sprintf("meow.Gag(%s)", argStr)
		case "isFurball":
			return fmt.Sprintf("meow.IsFurball(%s)", argStr)
		case "judge":
			g.ensureImport("testing")
			return fmt.Sprintf("meow_testing.Judge(%s)", argStr)
		case "expect":
			g.ensureImport("testing")
			return fmt.Sprintf("meow_testing.Expect(%s)", argStr)
		case "refuse":
			g.ensureImport("testing")
			return fmt.Sprintf("meow_testing.Refuse(%s)", argStr)
		case "seed":
			return "meow.NewNil()"
		default:
			return fmt.Sprintf("%s(%s)", ident.Name, argStr)
		}
	}
	return fmt.Sprintf("meow.Call(%s, %s)", g.genExpr(e.Fn), argStr)
}

func (g *Generator) genMemberCall(member *ast.MemberExpr, rawArgs []ast.Expr) string {
	obj, ok := member.Object.(*ast.Ident)
	if !ok {
		return fmt.Sprintf("/* unsupported member access on %T */", member.Object)
	}
	if _, imported := g.imports[obj.Name]; !imported {
		return fmt.Sprintf("/* package %s not imported */", obj.Name)
	}
	args := make([]string, len(rawArgs))
	for i, a := range rawArgs {
		args[i] = g.genExpr(a)
	}
	argStr := strings.Join(args, ", ")
	return fmt.Sprintf("meow_%s.%s(%s)", obj.Name, capitalizeFirst(member.Member), argStr)
}

func (g *Generator) genLambda(e *ast.LambdaExpr) string {
	params := make([]string, len(e.Params))
	for i, p := range e.Params {
		params[i] = p + " meow.Value"
	}
	body := g.genExpr(e.Body)
	return fmt.Sprintf("meow.NewFunc(\"lambda\", func(args ...meow.Value) meow.Value {\n"+
		"\t%s\n"+
		"\treturn %s\n"+
		"})", g.genLambdaParamBindings(e.Params), body)
}

func (g *Generator) genLambdaParamBindings(params []string) string {
	var lines []string
	for i, p := range params {
		lines = append(lines, fmt.Sprintf("%s := args[%d]", p, i))
		lines = append(lines, fmt.Sprintf("_ = %s", p))
	}
	return strings.Join(lines, "\n\t")
}

func (g *Generator) genList(e *ast.ListLit) string {
	items := make([]string, len(e.Items))
	for i, item := range e.Items {
		items[i] = g.genExpr(item)
	}
	return fmt.Sprintf("meow.NewList(%s)", strings.Join(items, ", "))
}

func (g *Generator) genMap(e *ast.MapLit) string {
	if len(e.Keys) == 0 {
		return "meow.NewMap(map[string]meow.Value{})"
	}
	entries := make([]string, len(e.Keys))
	for i := range e.Keys {
		key, ok := e.Keys[i].(*ast.StringLit)
		if !ok {
			entries[i] = fmt.Sprintf("/* unsupported map key: %T */", e.Keys[i])
			continue
		}
		entries[i] = fmt.Sprintf("%q: %s", key.Value, g.genExpr(e.Vals[i]))
	}
	return fmt.Sprintf("meow.NewMap(map[string]meow.Value{%s})", strings.Join(entries, ", "))
}

func (g *Generator) genIndex(e *ast.IndexExpr) string {
	return fmt.Sprintf("%s.(*meow.List).Get(int(%s.(*meow.Int).Val))", g.genExpr(e.Left), g.genExpr(e.Index))
}

func (g *Generator) genPipe(e *ast.PipeExpr) string {
	var fn ast.Expr
	var args []ast.Expr

	if call, ok := e.Right.(*ast.CallExpr); ok {
		fn = call.Fn
		args = make([]ast.Expr, 0, len(call.Args)+1)
		args = append(args, e.Left)
		args = append(args, call.Args...)
	} else {
		fn = e.Right
		args = []ast.Expr{e.Left}
	}

	return g.genCall(&ast.CallExpr{Token: e.Token, Fn: fn, Args: args})
}

func (g *Generator) genCatch(e *ast.CatchExpr) string {
	left := g.genExpr(e.Left)
	right := g.genExpr(e.Right)
	return fmt.Sprintf(
		"meow.GagOr(meow.NewFunc(\"~>\", func(args ...meow.Value) meow.Value {\n"+
			"\treturn %s\n"+
			"}), %s)", left, right)
}

func (g *Generator) genMatch(e *ast.MatchExpr) string {
	var b strings.Builder
	subject := g.genExpr(e.Subject)
	b.WriteString(fmt.Sprintf("func() meow.Value {\n\t__subject := %s\n", subject))
	for i, arm := range e.Arms {
		if _, ok := arm.Pattern.(*ast.WildcardPattern); ok {
			b.WriteString(fmt.Sprintf("\treturn %s\n", g.genExpr(arm.Body)))
			break
		}
		keyword := "if"
		if i > 0 {
			keyword = "} else if"
		}
		b.WriteString(fmt.Sprintf("\t%s %s {\n", keyword, g.genPatternCond("__subject", arm.Pattern)))
		b.WriteString(fmt.Sprintf("\t\treturn %s\n", g.genExpr(arm.Body)))
	}
	// close last if
	for _, arm := range e.Arms {
		if _, ok := arm.Pattern.(*ast.WildcardPattern); !ok {
			b.WriteString("\t}\n")
			break
		}
	}
	b.WriteString("\treturn meow.NewNil()\n}()")
	return b.String()
}

func (g *Generator) genMutatedExpr(original ast.Expr, entries []mutation.MutationEntry) string {
	// Save mutations temporarily and clear to avoid recursion
	saved := g.mutations
	g.mutations = nil

	var b strings.Builder
	b.WriteString("func() meow.Value {\n")
	for _, entry := range entries {
		fmt.Fprintf(&b, "\t\tif __mutant == %d { return %s }\n", entry.ID, g.genExpr(entry.Expr))
	}
	fmt.Fprintf(&b, "\t\treturn %s\n", g.genExpr(original))
	b.WriteString("\t}()")

	g.mutations = saved
	return b.String()
}

func (g *Generator) genPatternCond(subject string, pattern ast.Pattern) string {
	switch p := pattern.(type) {
	case *ast.LiteralPattern:
		return fmt.Sprintf("meow.MatchValue(%s, %s)", subject, g.genExpr(p.Value))
	case *ast.RangePattern:
		low := p.Low.(*ast.IntLit).Value
		high := p.High.(*ast.IntLit).Value
		return fmt.Sprintf("meow.MatchRange(%s, %d, %d)", subject, low, high)
	case *ast.WildcardPattern:
		return "true"
	default:
		return "true"
	}
}
