// Package codegen translates the Meow AST into Go source code.
// The generated code depends on the meowrt runtime package for dynamic typing.
package codegen

import (
	"fmt"
	"strings"

	"github.com/135yshr/meow/pkg/ast"
	"github.com/135yshr/meow/pkg/token"
)

// Generator produces Go source code from a Meow AST.
type Generator struct {
	funcs    []string
	topLevel []string
	indent   int
}

// New creates a new code generator.
func New() *Generator {
	return &Generator{}
}

// Generate produces Go source code from a Program AST.
func (g *Generator) Generate(prog *ast.Program) (string, error) {
	for _, stmt := range prog.Stmts {
		if fn, ok := stmt.(*ast.FuncStmt); ok {
			g.funcs = append(g.funcs, g.genFuncDecl(fn))
		} else {
			g.topLevel = append(g.topLevel, g.genStmt(stmt))
		}
	}
	return g.emit(), nil
}

func (g *Generator) emit() string {
	var b strings.Builder
	b.WriteString("// Code generated by meow compiler. DO NOT EDIT.\n")
	b.WriteString("package main\n\n")
	b.WriteString("import meow \"github.com/135yshr/meow/runtime/meowrt\"\n\n")

	for _, fn := range g.funcs {
		b.WriteString(fn)
		b.WriteString("\n\n")
	}

	b.WriteString("func main() {\n")
	for _, line := range g.topLevel {
		b.WriteString("\t")
		b.WriteString(line)
		b.WriteString("\n")
	}
	b.WriteString("}\n")
	return b.String()
}

func (g *Generator) genFuncDecl(fn *ast.FuncStmt) string {
	var b strings.Builder
	params := make([]string, len(fn.Params))
	for i, p := range fn.Params {
		params[i] = p + " meow.Value"
	}
	fmt.Fprintf(&b, "func %s(%s) meow.Value {\n", fn.Name, strings.Join(params, ", "))
	for _, stmt := range fn.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) genStmt(stmt ast.Stmt) string {
	switch s := stmt.(type) {
	case *ast.VarStmt:
		return fmt.Sprintf("var %s meow.Value = %s", s.Name, g.genExpr(s.Value))
	case *ast.AssignStmt:
		return fmt.Sprintf("%s = %s", s.Name, g.genExpr(s.Value))
	case *ast.ReturnStmt:
		if s.Value != nil {
			return fmt.Sprintf("return %s", g.genExpr(s.Value))
		}
		return "return meow.NewNil()"
	case *ast.ExprStmt:
		return g.genExpr(s.Expr)
	case *ast.IfStmt:
		return g.genIf(s)
	case *ast.WhileStmt:
		return g.genWhile(s)
	default:
		return fmt.Sprintf("/* unsupported stmt: %T */", stmt)
	}
}

func (g *Generator) genIf(s *ast.IfStmt) string {
	var b strings.Builder
	fmt.Fprintf(&b, "if (%s).IsTruthy() {\n", g.genExpr(s.Condition))
	for _, stmt := range s.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	if len(s.ElseBody) > 0 {
		b.WriteString("} else {\n")
		for _, stmt := range s.ElseBody {
			b.WriteString("\t")
			b.WriteString(g.genStmt(stmt))
			b.WriteString("\n")
		}
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) genWhile(s *ast.WhileStmt) string {
	var b strings.Builder
	fmt.Fprintf(&b, "for (%s).IsTruthy() {\n", g.genExpr(s.Condition))
	for _, stmt := range s.Body {
		b.WriteString("\t")
		b.WriteString(g.genStmt(stmt))
		b.WriteString("\n")
	}
	b.WriteString("}")
	return b.String()
}

func (g *Generator) genExpr(expr ast.Expr) string {
	switch e := expr.(type) {
	case *ast.IntLit:
		return fmt.Sprintf("meow.NewInt(%d)", e.Value)
	case *ast.FloatLit:
		return fmt.Sprintf("meow.NewFloat(%g)", e.Value)
	case *ast.StringLit:
		return fmt.Sprintf("meow.NewString(%q)", e.Value)
	case *ast.BoolLit:
		if e.Value {
			return "meow.NewBool(true)"
		}
		return "meow.NewBool(false)"
	case *ast.NilLit:
		return "meow.NewNil()"
	case *ast.Ident:
		return g.genIdent(e)
	case *ast.UnaryExpr:
		return g.genUnary(e)
	case *ast.BinaryExpr:
		return g.genBinary(e)
	case *ast.CallExpr:
		return g.genCall(e)
	case *ast.LambdaExpr:
		return g.genLambda(e)
	case *ast.ListLit:
		return g.genList(e)
	case *ast.IndexExpr:
		return g.genIndex(e)
	case *ast.PipeExpr:
		return g.genPipe(e)
	case *ast.MatchExpr:
		return g.genMatch(e)
	default:
		return fmt.Sprintf("/* unsupported expr: %T */", expr)
	}
}

func (g *Generator) genIdent(e *ast.Ident) string {
	return e.Name
}

func (g *Generator) genUnary(e *ast.UnaryExpr) string {
	switch e.Op {
	case token.MINUS:
		return fmt.Sprintf("meow.Negate(%s)", g.genExpr(e.Right))
	case token.NOT:
		return fmt.Sprintf("meow.Not(%s)", g.genExpr(e.Right))
	default:
		return fmt.Sprintf("/* unsupported unary: %v */", e.Op)
	}
}

func (g *Generator) genBinary(e *ast.BinaryExpr) string {
	l := g.genExpr(e.Left)
	r := g.genExpr(e.Right)
	switch e.Op {
	case token.PLUS:
		return fmt.Sprintf("meow.Add(%s, %s)", l, r)
	case token.MINUS:
		return fmt.Sprintf("meow.Sub(%s, %s)", l, r)
	case token.STAR:
		return fmt.Sprintf("meow.Mul(%s, %s)", l, r)
	case token.SLASH:
		return fmt.Sprintf("meow.Div(%s, %s)", l, r)
	case token.PERCENT:
		return fmt.Sprintf("meow.Mod(%s, %s)", l, r)
	case token.EQ:
		return fmt.Sprintf("meow.Equal(%s, %s)", l, r)
	case token.NEQ:
		return fmt.Sprintf("meow.NotEqual(%s, %s)", l, r)
	case token.LT:
		return fmt.Sprintf("meow.LessThan(%s, %s)", l, r)
	case token.GT:
		return fmt.Sprintf("meow.GreaterThan(%s, %s)", l, r)
	case token.LTE:
		return fmt.Sprintf("meow.LessEqual(%s, %s)", l, r)
	case token.GTE:
		return fmt.Sprintf("meow.GreaterEqual(%s, %s)", l, r)
	case token.AND:
		return fmt.Sprintf("meow.And(%s, %s)", l, r)
	case token.OR:
		return fmt.Sprintf("meow.Or(%s, %s)", l, r)
	default:
		return fmt.Sprintf("/* unsupported op: %v */", e.Op)
	}
}

func (g *Generator) genCall(e *ast.CallExpr) string {
	ident, isIdent := e.Fn.(*ast.Ident)
	args := make([]string, len(e.Args))
	for i, a := range e.Args {
		args[i] = g.genExpr(a)
	}
	argStr := strings.Join(args, ", ")

	if isIdent {
		switch ident.Name {
		case "nya":
			return fmt.Sprintf("meow.Nya(%s)", argStr)
		case "lick":
			return fmt.Sprintf("meow.Lick(%s)", argStr)
		case "picky":
			return fmt.Sprintf("meow.Picky(%s)", argStr)
		case "curl":
			return fmt.Sprintf("meow.Curl(%s)", argStr)
		case "len":
			return fmt.Sprintf("meow.Len(%s)", argStr)
		case "head":
			return fmt.Sprintf("meow.Head(%s)", argStr)
		case "tail":
			return fmt.Sprintf("meow.Tail(%s)", argStr)
		case "append":
			return fmt.Sprintf("meow.Append(%s)", argStr)
		case "toInt":
			return fmt.Sprintf("meow.ToInt(%s)", argStr)
		case "toFloat":
			return fmt.Sprintf("meow.ToFloat(%s)", argStr)
		case "toString":
			return fmt.Sprintf("meow.ToString(%s)", argStr)
		default:
			return fmt.Sprintf("%s(%s)", ident.Name, argStr)
		}
	}
	return fmt.Sprintf("meow.Call(%s, %s)", g.genExpr(e.Fn), argStr)
}

func (g *Generator) genLambda(e *ast.LambdaExpr) string {
	params := make([]string, len(e.Params))
	for i, p := range e.Params {
		params[i] = p + " meow.Value"
	}
	body := g.genExpr(e.Body)
	return fmt.Sprintf("meow.NewFunc(\"lambda\", func(args ...meow.Value) meow.Value {\n"+
		"\t%s\n"+
		"\treturn %s\n"+
		"})", g.genLambdaParamBindings(e.Params), body)
}

func (g *Generator) genLambdaParamBindings(params []string) string {
	var lines []string
	for i, p := range params {
		lines = append(lines, fmt.Sprintf("%s := args[%d]", p, i))
	}
	return strings.Join(lines, "\n\t")
}

func (g *Generator) genList(e *ast.ListLit) string {
	items := make([]string, len(e.Items))
	for i, item := range e.Items {
		items[i] = g.genExpr(item)
	}
	return fmt.Sprintf("meow.NewList(%s)", strings.Join(items, ", "))
}

func (g *Generator) genIndex(e *ast.IndexExpr) string {
	return fmt.Sprintf("%s.(*meow.List).Get(int(%s.(*meow.Int).Val))", g.genExpr(e.Left), g.genExpr(e.Index))
}

func (g *Generator) genPipe(e *ast.PipeExpr) string {
	left := g.genExpr(e.Left)
	// Pipe: left |> fn  =>  fn is called with left as first argument
	if call, ok := e.Right.(*ast.CallExpr); ok {
		ident, isIdent := call.Fn.(*ast.Ident)
		args := []string{left}
		for _, a := range call.Args {
			args = append(args, g.genExpr(a))
		}
		argStr := strings.Join(args, ", ")
		if isIdent {
			switch ident.Name {
			case "lick":
				return fmt.Sprintf("meow.Lick(%s)", argStr)
			case "picky":
				return fmt.Sprintf("meow.Picky(%s)", argStr)
			case "curl":
				return fmt.Sprintf("meow.Curl(%s)", argStr)
			default:
				return fmt.Sprintf("%s(%s)", ident.Name, argStr)
			}
		}
		return fmt.Sprintf("meow.Call(%s, %s)", g.genExpr(call.Fn), argStr)
	}
	// fn(left)
	return fmt.Sprintf("meow.Call(%s, %s)", g.genExpr(e.Right), left)
}

func (g *Generator) genMatch(e *ast.MatchExpr) string {
	var b strings.Builder
	subject := g.genExpr(e.Subject)
	b.WriteString(fmt.Sprintf("func() meow.Value {\n\t__subject := %s\n", subject))
	for i, arm := range e.Arms {
		if _, ok := arm.Pattern.(*ast.WildcardPattern); ok {
			b.WriteString(fmt.Sprintf("\treturn %s\n", g.genExpr(arm.Body)))
			break
		}
		keyword := "if"
		if i > 0 {
			keyword = "} else if"
		}
		b.WriteString(fmt.Sprintf("\t%s %s {\n", keyword, g.genPatternCond("__subject", arm.Pattern)))
		b.WriteString(fmt.Sprintf("\t\treturn %s\n", g.genExpr(arm.Body)))
	}
	// close last if
	for _, arm := range e.Arms {
		if _, ok := arm.Pattern.(*ast.WildcardPattern); !ok {
			b.WriteString("\t}\n")
			break
		}
	}
	b.WriteString("\treturn meow.NewNil()\n}()")
	return b.String()
}

func (g *Generator) genPatternCond(subject string, pattern ast.Pattern) string {
	switch p := pattern.(type) {
	case *ast.LiteralPattern:
		return fmt.Sprintf("meow.MatchValue(%s, %s)", subject, g.genExpr(p.Value))
	case *ast.RangePattern:
		low := p.Low.(*ast.IntLit).Value
		high := p.High.(*ast.IntLit).Value
		return fmt.Sprintf("meow.MatchRange(%s, %d, %d)", subject, low, high)
	case *ast.WildcardPattern:
		return "true"
	default:
		return "true"
	}
}
